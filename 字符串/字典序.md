# 练习场
## No1、3734. 大于目标字符串的最小字典序回文排列
https://leetcode.cn/problems/lexicographically-smallest-palindromic-permutation-greater-than-target/description/

## 题意
给你两个长度均为 n 的字符串 s 和目标字符串 target，它们都由小写英文字母组成。

返回 字典序最小的字符串 ，该字符串 既 是 s 的一个 回文排列 ，又是字典序 严格 大于 target 的。如果不存在这样的排列，则返回一个空字符串。

如果字符串 a 和字符串 b 长度相同，在它们首次出现不同的位置上，字符串 a 处的字母在字母表中的顺序晚于字符串 b 处的对应字母，则字符串 a 在 字典序上严格大于 字符串 b。

排列 是指对字符串中所有字符的重新排列。

如果一个字符串从前向后读和从后向前读都一样，则该字符串是 回文 的。
## 解题思路一（按位确定答案）
按位枚举当前位的最优填法

## 代码
```cpp
class Solution {
public:
    string lexPalindromicPermutation(string s, string target) {
        int n = s.size();
        int cnt[26] = {0};
        for (char c : s) cnt[c - 'a']++;

        // 看看长度为奇数的回文串中间要填什么字母
        int key = -1;
        for (int c = 0; c < 26; c++) if (cnt[c] % 2 == 1) {
            if (n % 2 == 0 || key >= 0) return "";
            key = c;
        }

        string ans;
        // 检查下一位填 c 行不行
        auto check = [&](int c) {
            cnt[c] -= 2; ans.push_back(c + 'a');
            string half = ans;
            // 剩下的字母从大到小填到后面的位里
            for (int d = 25; d >= 0; d--) for (int i = 1; i <= cnt[d] / 2; i++) half.push_back(d + 'a');
            // 构造回文串
            string tmp = half;
            if (key >= 0) tmp.push_back(key + 'a');
            reverse(half.begin(), half.end());
            tmp += half;
            if (tmp > target) return true;
            cnt[c] += 2; ans.pop_back();
            return false;
        };

        auto gao = [&]() {
            // 从小到大枚举这一位能不能填 c
            for (int c = 0; c < 26; c++) if (cnt[c] > 1 && check(c)) return true;
            return false;
        };

        // 从左到右枚举每一位
        for (int i = 1; i <= n / 2; i++) if (!gao()) return "";

        // 构造最终的回文串
        string ret = ans;
        if (key >= 0) ret.push_back(key + 'a');
        reverse(ans.begin(), ans.end());
        ret += ans;
        return ret > target ? ret : "";
    }
};
```
## 解题思路二（枚举第一个不同的位置）
枚举第一个不同的位置

## 代码
```cpp
class Solution {
public:
    string bigger(vector<char>& v) {
        int i = 0, j = v.size() - 1;
        while (i < j) {
            v[j] = v[i];
            i++;
            j--;
        }
        return string(v.begin(), v.end());
    }

    string lexPalindromicPermutation(string s, string t) {
        vector<int> c(26, 0);
        for (char ch : s) c[ch - 'a']++;
        int cnt = 0, p = -1;
        for (int i = 0; i < 26; i++) {
            if (c[i] % 2) cnt++, p = i;
            c[i] /= 2;
        }
        if (cnt > 1) return ""; 
        
        int n = s.size();
        vector<char> v(n);
        int mid = (n - 1) / 2;
        if (cnt == 1) v[(n - 1) / 2] = 'a' + p, mid--;
        auto tmp = c;
        bool f = true;
        for (int i = 0; i <= mid; i++) {
            if (tmp[t[i] - 'a'] == 0) {
                f = false;
                break;
            }
            tmp[t[i] - 'a']--;
            v[i] = t[i];
        }
        if (f) {
            auto ans = bigger(v);
            if (ans > t) return ans;
        }

        for (int i = mid; i >= 0; i--) {
            auto tmp = c;
            bool f = true;
            for (int j = 0; j < i; j++) {
                if (tmp[t[j] - 'a'] == 0) {
                    f = false;
                    break;
                }
                tmp[t[j] - 'a']--;
                v[j] = t[j];
            }
            if (!f) continue;
            int idx = -1;
            for (int j = t[i] - 'a' + 1; j < 26; j++) {
                if (tmp[j] > 0) {
                    idx = j;
                    v[i] = 'a' + idx;
                    tmp[j]--;
                    break;
                }
            }
            if (idx == -1) continue;
            for (int j = i + 1, p = 0; j <= mid; j++) {
                while (p < 26 && tmp[p] == 0) p++;
                v[j] = p + 'a';
                tmp[p]--;
            }
            auto ans = bigger(v);
            if (ans > t) return ans;
        }
        return "";
    }
};
```

## No2、3106. 满足距离约束且字典序最小的字符串
https://leetcode.cn/problems/lexicographically-smallest-string-after-operations-with-constraint/description/

## 题意
给你一个字符串 s 和一个整数 k 。

定义函数 distance(s1, s2) ，用于衡量两个长度为 n 的字符串 s1 和 s2 之间的距离，即：

字符 'a' 到 'z' 按 循环 顺序排列，对于区间 [0, n - 1] 中的 i ，计算所有「 s1[i] 和 s2[i] 之间 最小距离」的 和 。
例如，distance("ab", "cd") == 4 ，且 distance("a", "z") == 1 。

你可以对字符串 s 执行 任意次 操作。在每次操作中，可以将 s 中的一个字母 改变 为 任意 其他小写英文字母。

返回一个字符串，表示在执行一些操作后你可以得到的 字典序最小 的字符串 t ，且满足 distance(s, t) <= k 。
## 解题思路
按位确定答案，按位枚举当前位的最优填法

## 代码
```cpp
class Solution {
public:
    string getSmallestString(string s, int k) {
        string ans;
        int n = s.size();

        auto dist = [](int a, int b) {
            return min(abs(a - b), 26 - abs(a - b));
        };

        // 检查下一位填 c 行不行
        auto check = [&](int idx, int c) {
            int d = dist(s[idx] - 'a', c);
            if (d <= k) {
                k -= d;
                ans.push_back(c + 'a');
                return true;
            }
            return false;
        };

        auto gao = [&](int idx) {
            // 从小到大枚举这一位能不能填 c
            for (int c = 0; c < 26; c++) if (check(idx, c)) return true;
            return false;
        };

        // 从左到右枚举每一位
        for (int i = 0; i < n; i++) if (!gao(i)) return s;
        return ans;
    }
};
```

## No3、3720. 大于目标字符串的最小字典序排列
https://leetcode.cn/problems/lexicographically-smallest-permutation-greater-than-target/description/

## 题意
给你两个长度均为 n 且仅由小写英文字母组成的字符串 s 和 target。

返回 s 的 字典序最小的排列，要求该排列 严格 大于 target。如果 s 不存在任何字典序严格大于 target 的排列，则返回一个空字符串。

如果两个长度相同的字符串 a 和 b 在它们首次出现不同字符的位置上，字符串 a 对应的字母在字母表中出现在 b 对应字母的 后面 ，则字符串 a 字典序严格大于 字符串 b。

排列 是字符串中所有字符的一种重新排列。
## 解题思路
按位确定答案，按位枚举当前位的最优填法

## 代码
```cpp
class Solution {
public:
    string lexGreaterPermutation(string s, string t) {
        int n = s.size();
        int cnt[26] = {0};
        for (char c : s) cnt[c - 'a']++;

        string ans;
        // 检查下一位填 c 行不行
        auto check = [&](int c) {
            cnt[c]--;
            ans.push_back(c + 'a');
            // 剩下的字母从大到小填到后面的位里
            auto tmp = ans;
            for (int d = 25; d >= 0; d--) for (int i = 1; i <= cnt[d]; i++) tmp.push_back(d + 'a');
            if (tmp > t) return true;
            cnt[c]++;
            ans.pop_back();
            return false;
        };

        auto gao = [&]() {
            // 从小到大枚举这一位能不能填 c
            for (int c = 0; c < 26; c++) if (cnt[c] > 0 && check(c)) return true;
            return false;
        };

        // 从左到右枚举每一位
        for (int i = 0; i < n; i++) if (!gao()) return "";
        return ans;
    }
};
```

## No4、3518. 最小回文排列 II
https://leetcode.cn/problems/smallest-palindromic-rearrangement-ii/description/

## 题意
给你一个 回文 字符串 s 和一个整数 k。

返回 s 的按字典序排列的 第 k 小 回文排列。如果不存在 k 个不同的回文排列，则返回空字符串。

注意： 产生相同回文字符串的不同重排视为相同，仅计为一次。

如果一个字符串从前往后和从后往前读都相同，那么这个字符串是一个 回文 字符串。

排列 是字符串中所有字符的重排。

如果字符串 a 按字典序小于字符串 b，则表示在第一个不同的位置，a 中的字符比 b 中的对应字符在字母表中更靠前。
如果在前 min(a.length, b.length) 个字符中没有区别，则较短的字符串按字典序更小。
## 解题思路一、试填法+组合数
试填法+组合数

## 代码
```cpp
class Solution {
public:
    using ll = long long;
    //计算组合数的函数
    ll C(ll n, ll m, ll k) {
        ll res = 1;
        if(n == m || m == 0) {
            return 1;
        } else if (n < m) {
            return 0;
        }
        //乘法：先乘值小的再乘值大的 
        n = n - m + 1;
        for (int i = 1; i <= m; i++, n++) {
            res = res * n;
            res = res / i;
            if (res >= k) break;
        }
        return res;
    }

    string smallestPalindrome(string s, int k) {
        int n = s.size();
        int cnt[26] = {0};
        int key = -1;
        for (char c : s) cnt[c - 'a']++;
        for (int i = 0; i < 26; i++) {
            if (cnt[i] & 1) key = i;
            cnt[i] /= 2;
        }

        string ans;
        // 检查下一位填 c 行不行
        auto check = [&](int c) {
            cnt[c]--;
            ans.push_back(c + 'a');
            // 剩下的字母从大到小填到后面的位里
            ll sum = 0;
            for (int d = 25; d >= 0; d--) sum += cnt[d];
            ll num = 1;
            for (int d = 25; d >= 0 && num < k; d--) {
                num *= C(sum, cnt[d], k);
                sum -= cnt[d];
            }
            if (num >= k) {
                return true;
            }
            k -= num;
            cnt[c]++;
            ans.pop_back();
            return false;
        };

        auto gao = [&]() {
            // 从小到大枚举这一位能不能填 c
            for (int c = 0; c < 26; c++) if (cnt[c] > 0 && check(c)) return true;
            return false;
        };

        // 从左到右枚举每一位
        for (int i = 0; i < n / 2; i++) if (!gao()) return "";
        auto tmp = ans;
        reverse(tmp.begin(), tmp.end());
        if (key != -1) ans.push_back('a' + key);
        ans += tmp;
        return ans;
    }
};
```
## 解题思路二、尝填法+质因子表示组合数
https://leetcode.cn/problems/smallest-palindromic-rearrangement-ii/solutions/3649540/an-wei-que-ding-da-an-by-tsreaper-6tsw/
```cpp
class Solution {
public:
    string smallestPalindrome(string s, int K) {
        // 计算每种字母的出现次数
        int cnt[26] = {0};
        for (char c : s) cnt[c - 'a']++;

        // 看看要不要在答案中间放一个字符
        int mid = -1;
        for (int i = 0; i < 26; i++) {
            if (cnt[i] & 1) mid = i;
            cnt[i] /= 2;
        }

        int n = s.size();
        // 预处理每个数最大的质因数，用于质因数分解
        int fac[n + 1];
        memset(fac, 0, sizeof(fac));
        for (int i = 2; i <= n; i++) if (fac[i] == 0) for (int j = i; j <= n; j += i) fac[j] = i;
        int m = n / 2;

        unordered_map<int, int> mp;
        // 给当前结果乘（v = 1）或除（v = -1）x
        auto gao = [&](int x, int v) {
            // 其实就是添加或删除 x 的质因数
            for (; x > 1; x /= fac[x]) {
                int t = (mp[fac[x]] += v);
                if (t == 0) mp.erase(fac[x]);
            }
        };

        const long long INF = 1e9;
        const int MAXP = 20;
        // 计算当前结果，太大了就直接返回无穷大
        auto getVal = [&]() {
            if (mp.size() > MAXP) return INF;
            long long ret = 1;
            for (auto &p : mp) for (int i = 1; i <= p.second; i++) {
                ret *= p.first;
                if (ret > INF) return INF;
            }
            return ret;
        };

        // 计算初始的排列总数
        for (int i = 1; i <= m; i++) gao(i, 1);
        for (int i = 0; i < 26; i++) if (cnt[i] > 1) for (int j = 1; j <= cnt[i]; j++) gao(j, -1);
        if (getVal() < K) return "";

        string ans1, ans2;
        for (int i = 1; i <= m; i++) {
            gao(m + 1 - i, -1);
            // 枚举第 i 位的答案
            for (int j = 0; j < 26; j++) if (cnt[j]) {
                // 假设第 i 位填 j，剩下的排列还有几种
                gao(cnt[j], 1);
                long long t = getVal();
                if (t >= K) {
                    // 确定第 i 位是 j
                    cnt[j]--;
                    ans1.push_back(j + 'a');
                    ans2.push_back(j + 'a');
                    break;
                }
                // 跳过所有第 i 位是 j 的情况
                K -= t;
                gao(cnt[j], -1);
            }
        }
        if (mid >= 0) ans1.push_back(mid + 'a');
        reverse(ans2.begin(), ans2.end());
        return ans1 + ans2;
    }
};
```