# 前言
当方便求出`x`的倍数对应的结果时，则能使用倍数容斥的方法求出恰好为`x`对应的结果。

# 练习场
## No1、3725. 统计每一行选择互质整数的方案数
https://leetcode.cn/problems/count-ways-to-choose-coprime-integers-from-rows/description/

## 题意
给你一个由正整数组成的 m x n 矩阵 mat。

返回一个整数，表示从 mat 的每一行中 恰好 选择一个整数，使得所有被选整数的 最大公约数 为 1 的选择方案数量。

由于答案可能非常大，请将其 模 109 + 7 后返回。
## 解题思路
倍数容斥，方便求出最大公约数是`x`的倍数的数量，最大公约数**恰好**是`x`的数量等于前者减去最大公约数恰好是`2x`的数量，再减去最大公约数恰好是`3x`的数量,...,最终的答案则是最大公约数恰好是`1`的数量。

## 代码
```cpp
class Solution {
public:
    int countCoprime(vector<vector<int>>& v) {
        int MOD = 1e9 + 7;
        int mx = 0;
        for (auto& x : v) mx = max(mx, (int)(ranges::max(x)));
        vector<int> cnt_gcd(mx + 1);
        for (int i = mx; i > 0; i--) {
            long long res = 1; // 每行选一个 i 的倍数的方案数
            for (auto& row : v) {
                int cnt = 0;
                for (int x : row) {
                    if (x % i == 0) {
                        cnt++;
                    }
                }
                if (cnt == 0) {
                    res = 0;
                    break;
                }
                res = res * cnt % MOD; // 乘法原理
            }
            for (int j = i + i; j <= mx; j += i) {
                res -= cnt_gcd[j]; // 注意这里有减法，可能导致 res 是负数
            }
            cnt_gcd[i] = res % MOD;
        }
        return (cnt_gcd[1] + MOD) % MOD; // 保证结果非负
    }
};
```

## No2、3312. 查询排序后的最大公约数
https://leetcode.cn/problems/sorted-gcd-pair-queries/description/

## 题意
给你一个长度为 n 的整数数组 nums 和一个整数数组 queries 。

gcdPairs 表示数组 nums 中所有满足 0 <= i < j < n 的数对 (nums[i], nums[j]) 的 最大公约数 升序 排列构成的数组。

对于每个查询 queries[i] ，你需要找到 gcdPairs 中下标为 queries[i] 的元素。

请你返回一个整数数组 answer ，其中 answer[i] 是 gcdPairs[queries[i]] 的值。

gcd(a, b) 表示 a 和 b 的 最大公约数 。
## 解题思路
使用倍数容斥求出最大公约数是`x`的数量，然后使用前缀和+二分求答案。

## 代码
```cpp
class Solution {
public:
    vector<int> gcdValues(vector<int>& nums, vector<long long>& q) {
        int mx = ranges::max(nums);

        vector<int> cnt(mx + 1, 0);
        for (int x : nums) cnt[x]++;

        using ll = long long;
        vector<ll> cnt_gcd(mx + 1, 0);
        for (int i = mx; i > 0; i--) {
            ll c = cnt[i];
            for (int j = i + i; j <= mx; j += i) {
                c += cnt[j];
                cnt_gcd[i] -= cnt_gcd[j];
            }
            cnt_gcd[i] += c * (c - 1) / 2;
        }

        for (int i = 2; i <= mx; i++) cnt_gcd[i] += cnt_gcd[i - 1];
        int n = q.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            ans[i] = lower_bound(cnt_gcd.begin(), cnt_gcd.end(), q[i] + 1) - cnt_gcd.begin();
        }
        return ans;
    }
};
```