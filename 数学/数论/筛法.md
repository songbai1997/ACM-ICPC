# 埃式筛法求素数
时间复杂度`O(nlogn)`
```cpp
const int N = 100000;
int a[N]; // a[i] = 0表示 i 是素数 
void makeatble(int n)
{
	a[0] = a[1] = 1; // 0,1 不是素数 
	for (int i = 2; i <= n; i++) {
        if (!a[i]) {
	  	    for (int j = i + i; j <= n; j += i) a[j] = 1;
	    }
    }
} 
```

# 欧拉筛法求素数
埃式筛选法中合数是作为素数的倍数被筛去的，显然，如果每个合数仅被它最小的质因子筛去，算法的效率会更高。这就是欧拉筛法
```cpp
const int N = 10000;
int p[N + 1]; // p[0]存连续素数的个数，p数组存储连续素数
 
void getPrime()
{
	for (int i = 2; i <= N; i++) {
		if (!p[i]) p[++p[0]] = i;
		for (int j = 1; j <= p[0] && p[j] <= N / i; j++){
			p[p[j] * i] = 1;
			if (i % p[j] == 0) break; // 如果 p[j] 是 i 的最小质因子就跳出 
		}
	}
} 
```

# 筛法求无平方因子核 core
计算一个数去掉平方因子后的值
## 模板
```cpp
const int MX = 100'001;
int core[MX];

int init = [] {
    for (int i = 1; i < MX; ++i) {
        if (core[i] == 0) {
            for (int j = 1; i * j * j < MX; ++j) {
                core[i * j * j] = i;
            }
        }
    }
    return 0;
}();
```
## No1、3715. 完全平方数的祖先个数总和
https://leetcode.cn/problems/sum-of-perfect-square-ancestors/description/

## 题意
给你一个整数 n，以及一棵以节点 0 为根、包含 n 个节点（编号从 0 到 n - 1）的无向树。该树由一个长度为 n - 1 的二维数组 edges 表示，其中 edges[i] = [ui, vi] 表示在节点 ui 与节点 vi 之间有一条无向边。

同时给你一个整数数组 nums，其中 nums[i] 是分配给节点 i 的正整数。

定义值 ti 为：节点 i 的 祖先 节点中，满足乘积 nums[i] * nums[ancestor] 为 完全平方数 的祖先个数。

请返回所有节点 i（范围为 [1, n - 1]）的 ti 之和。

说明：
- 在有根树中，节点 i 的祖先是指从节点 i 到根节点 0 的路径上、不包括 i 本身的所有节点。
- 完全平方数是可以表示为某个整数与其自身乘积的数，例如 1、4、9、16。

## 解题思路
使用筛法预处理每个数的无平方因子核，然后使用哈希表和`dfs`算法计算结果

## 代码
```cpp
const int MX = 100'001;
int core[MX];

int init = [] {
    for (int i = 1; i < MX; ++i) {
        if (core[i] == 0) {
            for (int j = 1; i * j * j < MX; ++j) {
                core[i * j * j] = i;
            }
        }
    }
    return 0;
}();

class Solution {
public:
    using ll = long long;
    vector<vector<int>> g;
    unordered_map<int, int> cnt;

    ll dfs(int rt, int f, vector<int>& nums) {
        int c = core[nums[rt]];
        ll res = cnt[c]++;
        for (int c : g[rt]) {
            if (c == f) continue;
            res += dfs(c, rt, nums);
        }
        cnt[c]--;
        return res;
    }

    long long sumOfAncestors(int n, vector<vector<int>>& edges, vector<int>& nums) {
        g.assign(n, vector<int>());
        for (auto& e : edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        cnt.clear();
        return dfs(0, -1, nums);
    }
};
```