# 总结
- 1、对数组分块，并对查询进行排序：左端点所在块号为第一关键字升序排列，右端点为第二关键字升序排列。
- 2、仅涉及区间查询时优先考虑莫队算法。

# 题目一
B. Little Elephant and Array

https://codeforces.com/problemset/problem/220/B

## 题意
给定一个长度为n的整数数组，需要回答q次询问，每个询问用l，r表示，计算区间[l,r]内有多少个数字x满足出现x次。

## 解题思路
仅涉及区间查询，优先考虑莫队算法，使用一个数组统计每个值出现的次数，维护当前区间满足要求的数的个数即可。

## C++代码
```cpp
#include <bits/stdc++.h>

using namespace std;

int res = 0;
vector<int> cnt;

void add(int x)
{
    if (x >= cnt.size()) return;
    if (++cnt[x] == x) res++;
    else if (cnt[x] == x + 1) res--;   
}

void del(int x)
{
    if (x >= cnt.size()) return;
    if (--cnt[x] == x) res++;
    else if (cnt[x] == x - 1) res--;
}

int main()
{
    int n, m;
    scanf("%d %d", &n, &m);
    cnt.resize(n + 1, 0);
    vector<int> a(n);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    vector<pair<int, int>> q;
    for (int i = 0; i < m; i++) {
        int l, r;
        scanf("%d %d", &l, &r);
        q.emplace_back(--l, --r);
    }
    int block = sqrt(n);
    vector<int> id(m);
    iota(id.begin(), id.end(), 0);
    sort(id.begin(), id.end(), [&](int x, int y) {
        return (q[x].first / block != q[y].first / block ? q[x].first / block < q[y].first / block : q[x].second < q[y].second);
    });
    int L = 0, R = -1;
    res = 0;
    vector<int> ans(m);
    for (int i = 0; i < m; i++) {
        int idx = id[i];
        int l = q[idx].first;
        int r = q[idx].second;
        while (L > l) add(a[--L]);
        while (R < r) add(a[++R]);
        while (L < l) del(a[L++]);
        while (R > r) del(a[R--]);
        ans[idx] = res;
    }
    for (int i = 0; i < m; i++) printf("%lld\n", ans[i]);
    return 0;
}
```

# 题目二
[E. XOR and Favorite Number]

https://codeforces.com/problemset/problem/617/E

## 题意
给定一个长度为n的整数数组，需要回答m次询问，每个询问用l，r表示，计算区间[l,r]内有多少个子数组的xor值等于k。

## 解题思路
本题使用前缀异或值计算子数组的xor值，需要留意的是计算[l,r]区间的答案时，需要使用[l-1,r]范围的前缀xor值，同时需要将位置0的前缀xor值设置为0。

## C++代码
```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

const int N = (1 << 20);
ll cnt[N];
vector<int> a;

int k;
ll res = 0;

void del(int i)
{

    cnt[a[i]]--; // k可能为0，因此需要先减再统计
    res -= cnt[a[i] ^ k];
}

void add(int i)
{
    res += cnt[a[i] ^ k]; // k可能为0，因此需要先统计再加
    cnt[a[i]]++;
}

int main()
{
    int n, m;
    scanf("%d %d %d", &n, &m, &k);
    a.resize(n + 1);

    int block = sqrt(n);
    a[0] = 0;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        a[i] = a[i] ^ a[i - 1];
    }
    vector<pair<int, int>> q;
    for (int i = 0; i < m; i++) {
        int l, r;
        scanf("%d %d", &l, &r);
        q.emplace_back(--l, r); // 通过前缀异或计算的子数组结果，因此需要将左区间往前移动一个
    }
    vector<int> id(m);
    iota(id.begin(), id.end(), 0);
    sort(id.begin(), id.end(), [&](int x, int y) {
        return (q[x].first / block != q[y].first / block ? q[x].first / block < q[y].first / block : q[x].second < q[y].second);
    });
    int L = 0, R = -1;
    res = 0;
    vector<ll> ans(m);
    for (int i = 0; i < m; i++) {
        int idx = id[i];
        int l = q[idx].first;
        int r = q[idx].second;
        while (L > l) add(--L);
        while (R < r) add(++R);
        while (L < l) del(L++);
        while (R > r) del(R--);
        ans[idx] = res;
    }
    for (int i = 0; i < m; i++) printf("%lld\n", ans[i]);
    return 0;
}
```

# 题目三
[3636. 查询超过阈值频率最高元素]

https://leetcode.cn/problems/threshold-majority-queries/description/

## 题目
给你一个长度为`n`的整数数组`nums`和一个查询数组`queries`，其中 `queries[i] = [li, ri, thresholdi]`。返回一个整数数组`ans`，其中`ans[i]`等于子数组`nums[li...ri]`中出现至少`thresholdi`次的元素，选择频率最高的元素（如果频率相同则选择最小的元素），如果不存在这样的元素则返回-1。
## 解题思路
需要找到出现频率最高且值最小的元素，使用`vector<set>`结构维护每个频率对应的元素
## C++代码
```cpp
class Solution {
public:    
    vector<int> subarrayMajority(vector<int>& nums, vector<vector<int>>& qs) {
        auto a = nums;
        sort(a.begin(), a.end());
        a.resize(unique(a.begin(), a.end()) - a.begin());
        vector<int> who(a.size());
        for (auto& x : nums) {
            int idx = lower_bound(a.begin(), a.end(), x) - a.begin();
            who[idx] = x;
            x = idx;
        }

        int n = nums.size();
        int block = sqrt(n);
        int m = qs.size();
        vector<tuple<int, int, int, int>> q(m);
        for (int i = 0; i < m; i++) q[i] = make_tuple(i, qs[i][0], qs[i][1], qs[i][2]);
        sort(q.begin(), q.end(), [&](tuple<int, int, int, int>& a, tuple<int, int, int, int>& b) {
            int al = get<1>(a) / block;
            int bl = get<1>(b) / block;
            return al != bl ? al < bl : get<2>(a) < get<2>(b);
        });

        vector<set<int>> f(n + 1);
        vector<int> cnt(a.size(), 0);

        int mx = -1;

        vector<int> ans(m, -1);
        auto add = [&](int x) {
            if (cnt[x] > 0) f[cnt[x]].erase(x);
            f[++cnt[x]].insert(x);
            if (cnt[x] > mx) mx = cnt[x];
        };

        auto del = [&](int x) {
            if (cnt[x] == 0) return;
            f[cnt[x]].erase(x);
            if (--cnt[x] > 0) {
                f[cnt[x]].insert(x);
            }
            if (f[mx].empty()) mx--;
        };
        
        int L = 0, R = -1;
        for (auto& t : q) {
            int id = get<0>(t);
            int l = get<1>(t);
            int r = get<2>(t);
            int th = get<3>(t);
            while (L > l) add(nums[--L]);
            while (R < r) add(nums[++R]);
            while (L < l) del(nums[L++]);
            while (R > r) del(nums[R--]);
            if (mx >= th) ans[id] = who[*f[mx].begin()];
        }
        return ans;
    }
};
```
