# 总结
针对添加简单、删除困难的场景，回滚莫队的优势会更明显。回滚莫队的核心思想
- 若查询的左右端点位于同一个块，直接使用暴力算法。
- 若查询的左右端点位于不同块，右端点从下一个块的第一个位置开始递增，左端点每次都从当前块的最后一个位置往前移动，左右端点的移动都保证只有添加操作。（当询问的左端点所在的块移变化时，才需要重置右端点为下一个块的第一个位置）

# 题目一
[3636. 查询超过阈值频率最高元素]

https://leetcode.cn/problems/threshold-majority-queries/description/

## 题目
给你一个长度为`n`的整数数组`nums`和一个查询数组`queries`，其中 `queries[i] = [li, ri, thresholdi]`。返回一个整数数组`ans`，其中`ans[i]`等于子数组`nums[li...ri]`中出现至少`thresholdi`次的元素，选择频率最高的元素（如果频率相同则选择最小的元素），如果不存在这样的元素则返回-1。
## 解题思路
此题的添加操作简单，但是删除操作困难，因此使用回滚莫队。
## C++代码
```cpp
class Solution {
public:
    vector<int> subarrayMajority(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), m = queries.size();
        // 离散化
        auto a = nums;
        sort(a.begin(), a.end());
        a.resize(unique(a.begin(), a.end()) - a.begin());
        vector<int> index_to_value(n);
        for (int i = 0; i < n; i++) index_to_value[i] = lower_bound(a.begin(), a.end(), nums[i]) - a.begin();

        vector<int> cnt(a.size() + 1);
        int max_cnt = 0, min_val = 0;

        auto add = [&](int i) {
            int v = index_to_value[i];
            int c = ++cnt[v];
            int x = nums[i];
            if (c > max_cnt) {
                max_cnt = c;
                min_val = x;
            } else if (c == max_cnt) {
                min_val = min(min_val, x);
            }
        };

        vector<int> ans(m, -1);
        int block_size = sqrt(n);

        struct Query {
            int bid, l, r, threshold, qid; // [l,r) 左闭右开
        };

        vector<Query> qs;
        for (int i = 0; i < m; i++) {
            auto& q = queries[i];
            int l = q[0], r = q[1] + 1, threshold = q[2]; // 左闭右开
            // 大区间离线（保证 l 和 r 不在同一个块中）
            if (r - l > block_size) {
                qs.emplace_back(l / block_size, l, r, threshold, i);
                continue;
            }
            // 小区间暴力
            for (int j = l; j < r; j++) {
                add(j);
            }
            if (max_cnt >= threshold) {
                ans[i] = min_val;
            }
            // 重置数据
            for (int j = l; j < r; j++) {
                cnt[index_to_value[j]]--;
            }
            max_cnt = 0;
        }

        ranges::sort(qs, {}, [](auto& q) { return pair(q.bid, q.r); });

        int r;
        for (int i = 0; i < qs.size(); i++) {
            auto& q = qs[i];
            int l0 = (q.bid + 1) * block_size;
            if (i == 0 || q.bid > qs[i - 1].bid) { // 遍历到一个新的块
                r = l0; // 右端点移动的起点
                // 重置数据
                ranges::fill(cnt, 0);
                max_cnt = 0;
            }
            // 右端点从 r 移动到 q.r（q.r 不计入）
            for (; r < q.r; r++) {
                add(r);
            }
            int tmp_max_cnt = max_cnt, tmp_min_val = min_val;
            // 左端点从 l0 移动到 q.l（l0 不计入）
            for (int j = q.l; j < l0; j++) {
                add(j);
            }
            if (max_cnt >= q.threshold) {
                ans[q.qid] = min_val;
            }
            // 回滚
            max_cnt = tmp_max_cnt;
            min_val = tmp_min_val;
            for (int j = q.l; j < l0; j++) {
                cnt[index_to_value[j]]--;
            }
        }
        return ans;
    }
};
```